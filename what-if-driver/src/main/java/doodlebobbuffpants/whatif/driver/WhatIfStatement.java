package doodlebobbuffpants.whatif.driver;

import doodlebobbuffpants.whatif.driver.exception.WhatIfSqlException;
import lombok.experimental.Delegate;

import java.io.IOException;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class WhatIfStatement implements Statement {
    @Delegate(types = Statement.class, excludes = StatementDelegateExclusion.class)
    private final Statement wrappedStatement;
    private final List<String> batch;
    private final WhatIfWriter writer;
    private final WhatIfConnection connection;

    public WhatIfStatement(WhatIfWriter writer, WhatIfConnection connection) throws SQLException {
        this.wrappedStatement = connection.getWrappedConnection().createStatement();
        this.batch = new ArrayList<>();
        this.writer = writer;
        this.connection = connection;
    }

    @Override
    public ResultSet executeQuery(String sql) {
        try {
            writer.writeLine(sql);
        } catch (IOException e) {
            throw new WhatIfSqlException(sql, e);
        }
        return null;
    }

    @Override
    public int executeUpdate(String sql) {
        executeQuery(sql);
        return 0;
    }

    @Override
    public void close() throws SQLException {
        writer.flush();
        wrappedStatement.close();
    }

    @Override
    public void cancel() throws SQLException {
        writer.flush();
        wrappedStatement.cancel();
    }

    @Override
    public boolean execute(String sql) {
        executeQuery(sql);
        return false;
    }

    @Override
    public void addBatch(String sql) {
        batch.add(sql);
    }

    @Override
    public void clearBatch() {
        batch.clear();
    }

    @Override
    public int[] executeBatch() {
        List<Integer> result = new ArrayList<>();
        for (String sql : batch) {
            executeQuery(sql);
            result.add(0);
        }
        clearBatch();
        return result.stream().mapToInt(i -> i).toArray();
    }

    @Override
    public Connection getConnection() {
        return connection;
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) {
        executeQuery(sql);
        return 0;
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) {
        executeQuery(sql);
        return 0;
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) {
        executeQuery(sql);
        return 0;
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) {
        executeQuery(sql);
        return false;
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) {
        executeQuery(sql);
        return false;
    }

    @Override
    public boolean execute(String sql, String[] columnNames) {
        executeQuery(sql);
        return false;
    }

    @SuppressWarnings("unused")
    private interface StatementDelegateExclusion {
        ResultSet executeQuery(String sql) throws SQLException;
        int executeUpdate(String sql) throws SQLException;
        void close() throws SQLException;
        void cancel() throws SQLException;
        boolean execute(String sql) throws SQLException;
        void addBatch(String sql) throws SQLException;
        void clearBatch() throws SQLException;
        int[] executeBatch() throws SQLException;
        Connection getConnection() throws SQLException;
        int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException;
        int executeUpdate(String sql, int[] columnIndexes) throws SQLException;
        int executeUpdate(String sql, String[] columnNames) throws SQLException;
        boolean execute(String sql, int autoGeneratedKeys) throws SQLException;
        boolean execute(String sql, int[] columnIndexes) throws SQLException;
        boolean execute(String sql, String[] columnNames) throws SQLException;
    }
}
